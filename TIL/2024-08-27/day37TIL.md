# 오늘의 문제
[백준] 9094. 수학적 호기심

## 문제 설명
두 정수 `n`과 `m`이 주어졌을 때 `0 < a < b < n`을 만족하는 정수 쌍 `(a,b)` 중에 
`(a^2 + b^2 + m) / (a * b)`가 정수가 되는 경우의 수를 구하는 문제이다. 
- 입력 
  - 첫 번째 줄에 테스트 케이스 개수 T가 주어진다.
  - 다음 `T`개의 줄에 각 테스트 케이스에 대한 정수 `n`과 `m`이 주어진다. 
- 출력
  - 각 테스트 케이스마다 문제의 조건을 만족하는 `(a,b)` 쌍의 개수를 출력한다. 
- 입출력 예 
  - 입력 예
    ```java
    3
    10 1
    20 3
    30 4
    ```
  - 출력 예
    ```java
    2
    4
    5
    ```

## 문제 접근 방식 
1. `BufferedReader`를 통해 문제에서 주어진 입력을 받는다.
2. 각 테스트 케이스의 `n`과 `m`을 읽어온다. 
3. `countPairs()` 메서드를 호출해 문제에서 주어진 수식의 분자와 분모를 나눴을 때 나머지가 `0`인 경우 `cnt`를 증가시킨다.
4. 메서드 결과를 출력한다. 

---

## 거듭제곱 메서드 사용하기 
`Math.pow(base, exponent)` 메서드를 사용하면 거듭제곱을 구할 수 있다. 
결과는 기본적으로 `double` 타입으로 반환되기 때문에 필요한 경우 타입 캐스팅이 필요하다. 

---

## 코드 개선 
- 중복 계산 제거하기 : 현재 코드에서는 `a`과 `b`의 값이 바뀔 때마다 `(a^2 + b^2 + m)` 계산이 반복적으로 수행 되고 있다.
메모이제이션을 사용해 이미 계산한 제곱 값을 저장하고 재사용함으로써 성능을 개선할 수 있다.
```java
int[] squares = new int[n]; // 메모이제이션을 위한 배열

// 사전에 모든 제곱 값 계산하기 
for (int i = 1; i < n; i++) {
    squares[i] = i * i;
}

// a와 b의 가능한 모든 쌍 탐색
for (int a = 1; a < n; a++) {
    for (int b = a + 1; b < n; b++) {
        int numerator = squares[a] + squares[b] + m; // 메모이제이션된 제곱 값 사용
        int denominator = a * b;

        if (numerator % denominator == 0) {
            cnt++;
        }
    }
}

```

---

## 시간복잡도 
알고리즘 시간복잡도는 이중 `for문`을 사용하기 때문에 `O(n^2)`이다. 


  
