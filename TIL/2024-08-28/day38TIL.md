# 오늘의 문제
[LeetCode] 409. Longest Palindrome

## 문제 설명
소문자 또는 대문자로 구성된 문자열 `s`가 주어졌을 때, 해당 문자로 작성할 수 있는 가장 긴 회문의 길이를 반환하는 문제이다. 
- 입출력 예 
  - 입력 예 : `s = "abccccdd"`
  - 출력 예 : `7`

## 문제 접근 방식 
1. 각 문자의 빈도수 구한다.
2. 빈도수가 짝수개면 빈도수를 `len`에 더한다. 
3. 빈도수가 홀수개면 빈도수가 홀수개인 문자는 하나를 제외한 나머지 문자만 사용할 수 있으므로 빈도수에서 `1`을 뺀 값을 `len`에 더한다. 
4. 빈도수가 홀수개인 문자가 존재하면 회문의 중앙에 들어갈 수 있기 때문에 최종 길이에 `1`을 더한다. 
5. 계산된 최종 길이를 반환한다. 

---

## 해쉬맵 사용하기 
빈도수를 계산하기 위해 자료구조인 해쉬맵을 사용했다. 각 문자를 `key`로 받고 문자에 해당하는 
빈도수를 `value`로 저장한다. 
`map.put()` 메서드를 사용해 `map.getOrDefault(ch,0)` 메서드가 반환한 값에 `1`을 더한 다음 해시 맵에 저장한다. 
`map.getOrDefault()` 메서드는 특정 문자의 빈도수를 가져오기 위해 사용되고 만약 문자가 맵에 존재하지 않을 경우 기본값인 `0`을 반환한다. 

---

## 빈도수가 홀수개인 경우  
회문을 만들기 위해서는 양쪽의 대칭이 맞아야 한다. 따라서 모든 문자는 짝수 번 출력해야 한다.
하지만 홀수 번 출력하는 문자도 가운데 위치하면 대칭이 되기 때문에 회문에 한 번은 포함될 수 있다. 
따라서 빈도수가 홀수인 문자가 있는 경우, 그 중 하나를 제외한 나머지 문자는 `1`을 빼주어 짝수 대칭을 만들고 
홀수인 문자 하나는 회문 중앙에 배치한다. 

---


## 시간복잡도 
알고리즘 시간복잡도는 문자열을 한 번 순회해서 각 문자의 빈도수를 계산하고
그 결과를 해시맵에 저장하기 때문에 `O(n)`이다. 여기서 `n`은 문자열의 길이이다. 
해시맵의 삽입 및 조회 연산이 평균적으로 `O(1)`이므로 전체 시간복잡도는 문자열의 길이에
비례해서 선형 시간이 소요된다. 


---

## 다른 접근 방식 
문제에서 각 문자의 빈도수만 필요로 하기 때문에 고정 크기의 정수 배열 `int[128]`을 
사용해서 ASCII 문자 집합에 해당하는 문자의 빈도수를 저장하는 방법을 사용할 수 있다. 
이 방법은 배열을 사용하기 때문에 메모리를 줄일 수 있다. 

  
