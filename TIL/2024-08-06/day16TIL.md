
# 오늘의 문제
[프로그래머스] 최소직사각형 

## 문제 설명
주어진 이차원 배열 `sizes`에는 각 명함의 가로와 세로 크기가 저장돼 있다. 
모든 명함을 담을 수 있는 최적의 지갑 크기를 구해야 한다. 
만약 `sizes`가 `[[60, 50], [30, 70], [60, 30], [80, 40]]`인 경우, 가로의 최대값은 `80`이고 세로의 최대값은 `70`이다.
하지만 `[30,70]` 크기의 명함을 눕히면 `[70,30]`이 되므로 가로의 최대값은 `80`이고 세로의 최대 값은 `50`이 된다.
따라서 지갑의 크기는 `가로 x 세로`인 `4000`이 반환 된다. 

## 문제 접근 방식 
1. 가로가 세로보다 작으면 둘의 순서를 바꿔 정렬한다.
2. 가로의 최대값과 세로의 최대 값을 구한다.
3. 구한 값을 곱해 결과 값을 반환한다. 

---

## 이차원 배열의 구조 이해하기 
문제에서 주어진 `sizes`는 이차원 배열로 `sizes[i]`는 `i`번째 카드의 크기를 나타낸다. 
반복문에서 쓰인 `sizes[i][0]`는 `i`번째 카드의 가로 길이를 의미하고 `sizes[i][1]`은 카드의 세로 길이를 의미한다. 

---

## 배열을 정렬하는 이유 
문제에서 주어진 예시를 보면 지갑의 최적 크기를 구하기 위해 각 카드의 가로와 세로 길이를 비교하여 큰 값을 가로로, 작은 값을 세로로 정렬하는 작업을 거친다. 
이는 모든 카드의 긴 쪽이 항상 가로에 위치하도록 하여 계산을 단순화하기 위함이다. 
이렇게 하면 지갑의 가로와 세로 중 최대값을 쉽게 찾을 수 있다. 

---

## Math.max를 통한 다른 풀이 
`Math.max`를 이용하면 다른 풀이를 할 수 있다. 
첫 번째 변수에 각 카드의 가로와 세로 중 큰 값을 선택한 뒤, 그 중 최대값을 저장한다.
두 번째 변수에 각 카드의 가로와 세로 중 작은 값을 선택한 뒤, 그 중 최대값을 저장한다.
결론적으로, 모든 카드의 **가로와 세로 값 중 큰 값들의 최대값**과 **작은 값들의 최대값**을 저장하게 되는 것이다. 이를 통해 지갑의 최적 크기를 계산할 수 있다.
```java
length = Math.max(length, Math.max(card[0], card[1]));
height = Math.max(height, Math.min(card[0], card[1]));
```

   


  
