
# 오늘의 문제
[LeetCode] 897. Increasing Order Search Tree

## 문제 설명
이진 탐색 트리가 주어졌을 때 노드를 크기 순서로 정렬하는 문제이다.  
단, 모든 노드는 오른쪽 자식 노드만 가져야 한다. 
예를 들어 입력값이 `root = [5,3,6,2,4,null,8,1,null,null,null,7,9]` 인 경우,
`[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]` 가 된다. 

## 문제 접근 방식 
1. 중위 순회 함수를 만들어 트리를 탐색한다. 
2. 이 때 중위 순회한 결과를 리스트에 저장한다.
3. 리스트에 저장된 중위 순회 결과를 바탕으로 새로운 트리를 생성한다.
4. 트리는 현재 노드의 오른쪽 자식 노드를 연결하는 방식으로 생성하여 반환한다. 

---

## 중위순회를 하는 이유
이진 탐색 트리는 **왼쪽 자식 < 부모 < 오른쪽 자식** 순의 크기로 노드가 구성돼 있다. 
**중위 순회 방식**을 택하면 **왼쪽 자식 - 부모 - 오른쪽 자식** 순으로 노드를 순회 하기 때문에 자연스럽게 **오름차순**으로 순회하게 된다. 
만약 **내림차순**으로 순회하고 싶다면 **오른쪽 자식 - 부모 - 왼쪽 자식** 순으로 노드를 방문 하여 순회하면 된다. 

---

## 오른쪽 자식 노드만 갖는 새로운 트리 
중위 순회한 결과를 리스트에 저장했지만 이를 그대로 반환할 수 없다. 
왜냐하면 문제에서 주어진 조건이 있기 때문이다. 
이를 충족하기 위해 오른쪽 자식 노드만 갖는 새로운 트리를 생성해야 한다. 

먼저 새로운 트리를 만들기 위한 임시 노드를 생성한다. 
그리고 현재 노드를 가리키는 포인터를 선언해 임시 노드를 저장한다. 
이렇게 하는 이유는 트리의 루프를 쉽게 반환하기 위해서이다. 
임시 노드 `tempNode`는 트리의 실제 루트가 아니고 새로운 트리를 구성하기 위한 임시 시작점으로 사용된다. 
```java
TreeNode tempNode = new TreeNode(0);
TreeNode currnetNode = tempNode; 
```

그 다음 `for-each`문을 사용해 리스트를 순환한다. 
반복문 안을 살펴보면 새로운 노드를 현재 노드의 오른쪽 자식으로 연결한다.
그리고 현재 노드를 새로 만든 노드로 이동시킨다. 이를 반복하면 오른쪽 자식 노드만 가진 트리가 완성된다. 
```java
for(int val : inOrderList) {
            currnetNode.right = new TreeNode(val);
            currnetNode = currnetNode.right;
        }
```

---

## 임시 노드의 오른쪽 자식 노드 반환 
반환 값을 보면 `tempNode.right`를 리턴하고 있다.
`tempNode`는 현재 오른쪽 자식 노드만 있는 트리의 시작점 역할을 하는 임시 노드이다. 
그렇다면 왜 `tempNode`가 아닌 `tempNode.right`를 반환하는 것일까? 

그 이유는 `tempNode` 자체는 트리의 실제 루트가 아니라 트리의 시작점을 잡기 위해 사용된 임시 노드일 뿐이기 때문이다. 
실제로 데이터가 들어있는 것이 아니기 때문에 `tempNode`는 유효한 트리의 일부가 아니고 이를 반환할 시 임시 노드 생성 시 초기 값인 `tempNode (0)`이 반환되게 된다.
`tempNode.right`는 루트 노드 `1`부터 시작해 오른쪽 자식 노드로 연결된 새로운 트리 값을 반환한다. 

`tempNode` 반환 : tempNode (0) -> 1 -> 2 -> 3
`tempNode.right` 반환 : 1 -> 2 -> 3


   


  
