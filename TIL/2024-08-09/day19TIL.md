
# 오늘의 문제
[프로그래머스] 과일 장수

## 문제 설명
`k`  `m` `socre` 가 주어졌을 때 과일 장수가 얻을 수 있는 최대 이익을 계산하는 문제이다. 
사과는 `1` 점 부터 `k` 점까지 상태에 따라 점수가 매겨지며, 점수가 높을 수록 품질이 좋은 사과이다. 
한 상자에 사과 `m` 개를 담아 포장하고, 가격은 상자에 담긴 사과 중 가장 낮은 점수 `(p)`에 `m`을 곱한 값이다. 

예를 들어 입력값이 `3, 4, [1, 2, 3, 1, 2, 3, 1]` 인 경우, 출력값은 `8` 이 된다. 

## 문제 접근 방식 
1. 점수가 담긴 배열 `score` 를 내림차순으로 정렬한다.
2. 정렬된 점수를 `m` 개씩 묶어 각 묶음에서 최소값을 찾는다. 
3. 각 묶음의 최소 점수에 `m` 을 곱해 이익을 계산한다.
4. 이를 모두 더한 값을 결과로 반환한다. 

---

## 그리디 알고리즘 
그리디 알고리즘은 문제를 해결하는 과정에서 각 단계에서 최적이라고 생각되는 선택을 하여 최종적인 해답에 도달하는 방법이다. 
각 부분에서의 최적 선택이 전체 문제의 최적 해를 보장할 때 사용하는 것이 효과적이다. 
1. 선택 절차 : `score` 배열 내림차순 정렬
2. 적절성 검사 : 각 묶음의 `m` 번째 작은 점수를 선택해 연산
3. 해답 검사 : 모든 묶음에서 이익을 계산해 최종적으로 최대 이익 반환

---

## int 배열을 Integer 배열로 변환하기 
기본 데이터 타입 `int`를 객체 타입인 `Integer`로 변환해 `Comparator`를 사용한다. 
이 때 `boxed()` 메서드를 사용하면 기본형 데이터 타입을 그에 대응하는 객체 타입으로 변환할 수 있다. 
```java
Integer scores[] = Arrays.stream(score).boxed().toArray(Integer[]::new);
```

---

## 역방향 반복문을 사용한 풀이 
내림차순 정렬 대신 오름차순 정렬을 사용하고 역방향 반복문을 통해 동일한 결과를 낼 수 있다. 
이 방법은 `Integer` 변환 과정과 내림차순 정렬을 생략할 수 있어 효과적이다. 
```java
import java.util.Arrays;

class Solution {
    public int solution(int k, int m, int[] score) {
        int answer = 0;
        int len = score.length;

        Arrays.sort(score);
        
        for (int i = len - m; i >= 0; i -= m) {
            answer += score[i] * m;
        }

        return Math.max(answer, 0);
    }
}
```


   


  
